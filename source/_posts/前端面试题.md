---
title: 前端面试题
date: 2023-1-1 00:00:00
categories: "面试"
description: 摘录一些面试中遇到的高频前端面试题（持续更新中）
cover: https://csheng-fly.oss-cn-guangzhou.aliyuncs.com/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98.png
sticky: 1
---

# Vue
## 组件通信
- 父传子：父亲通过v-bind传递参数，子级通过`props`接收参数
- 子传父：子组件使用`$emit`派发事件，父组件使用v-on监听事件
- 兄弟：事件总线(eventbus)，在vue原型上定义一个新的原型，然后采用`$emit`和`$on`进行获取传递的值
- 祖孙：组件给后代组件传值，通过依赖注入(`provide/inject`)

## v-if和v-for哪个优先级更高？
首先在实际开发阶段，不应该把v-if和v-for在同一个标签中使用，
- 在vue2中，v-for的优先级高于v-if，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能；
- 在vue3则完全相反，v-if的优先级高于v-for,所以v-if执行时，它调用的变量还不存在，就会导致异常。

通常有两种情况下导致我们这样做
- 为了过滤列表中的项目(比如：v-for="user in users" v-if="user.isActive")。此时定义一个计算属性（比如：activeUsers）,让其返回过滤后的列表即可（比如：users.filter(u=>u.isActive)）
- 为了避免渲染本应该被隐藏的列表（比如v-for="user in users" v-if="shouldShowUsers"），此时把v-if移至容器元素上（比如ul、ol）或者外面包一层template即可。

```jsx
<div id="app">
    <p v-for="child in children" v-if="isFolder">{{child.title}}</p>
</div>
<script>
    const vm = new Vue({
        el:'#app',
        data(){
            return{
               children:[
                 {
                    title:'red'
                 },
                 {
                    title:'green'
                 }
               ]
            }
        },
        computed:{
            isFolder(){
                return this.children&&this.children.length>0
            }
        }
    })
</script>
```

优化后代码：

```jsx
<template v-if="isFolder">
     <p v-for="child in children">{{child.title}}</p>
</template>
```

## Vue的生命周期以及各阶段做的事
<table><tr><td bgcolor=MistyRose>每个Vue组件实例被创建后都会经过一系列初始化步骤（它需要数据观测，模板编译，挂载实例到dom上，以及数据变化时更新dom），
这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段有机会添加他们自己的代码。</td></tr></table>


Vue生命周期总共可以分为8个阶段：**创建前后, 载入前后, 更新前后, 销毁前后**，以及一些特殊场景的生命周期。
vue3中新增了三个用于调试和服务端渲染场景。

- beforeCreate/created
- beforeMount/mounted
- beforeUpdate/updated
- beforeDestroy/destroyed
- activated/deactivated

各阶段做的事情：
- beforeCreate：通常用于插件开发中执行一些初始化任务
- created：组件初始化完毕，可以访问各种数据，获取接口数据等
- mounted：dom已创建，可用于获取访问数据和dom元素；访问子组件等。
- beforeUpdate：此时view层还未更新，可用于获取更新前各种状态
- updated：完成view层的更新，更新后，所有状态已是最新
- beforeUnmount：实例被销毁前调用，可用于一些定时器或订阅的取消
- unmounted：销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器

## vue双向绑定以及实现原理

<table><tr><td bgcolor=MistyRose>vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。<br/> v-model是语法糖，默认情况下相当于:value和@input。</td></tr></table>

<font color=red>使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好</font>

通常在表单项上使用v-model
原生的表单项可以直接使用v-model，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件
我做过测试，输出包含v-model模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。

## nextTick
<table><tr><td bgcolor=MistyRose>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</td></tr></table>

- nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法
- Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用。
- 所以当我们想在修改数据后立即看到dom执行结果就需要用到nextTick方法。
- 比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可。
- 我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。