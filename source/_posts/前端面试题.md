---
title: 前端面试题
date: 2022-11-28 00:00:00
categories: "面试"
description: 摘录一些面试中遇到的高频前端面试题（持续更新中）
cover: https://csheng-fly.oss-cn-guangzhou.aliyuncs.com/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98.png
toc_number: false
toc_expand: true
sticky: 1
---

# HTML/CSS

## css 选择器权重值

- !important > 行内元素 > ID 选择器 > 类选择器 > 标签 > 通配符

## HTML5/CSS3 的新特性

{% tabs test %}

<!-- tab HTML5的新特性 -->

- 只有一种 DOCTYPE ⽂件类型声明(统 一标准)：`<!DOCTYPE html>`
- 增加了一些新的标签元素(功能, 语义化）：section, footer, header, nav
- input 支持了几个新的类型值：date, email, url 等等
- 新增了一些标签属性：charset（⽤于 meta 标签）；async（⽤于 script 标 签）
- 新增的全域属性：contenteditable, draggable... hidden...
- 新增 API：本地存储, 地理定位, Canvas 绘图, 拖拽 API, 即时通信 WebSocket
<!-- endtab -->

<!-- tab CSS3的新特性 -->

- 伪元素
- 弹性布局 flex
- 媒体查询
- 圆角
- 渐变
- 阴影
- 平面转换
- 3D 转换
- 动画
  <!-- endtab -->
  {% endtabs %}

## 块级元素和行内元素

块级元素: div，h1，p，form，header，footer，section

- 在文档流中占据一整行
- 可以设置宽度和高度
- 可以设置内外边距和边框

行内元素: a，span，button，input，label，select

- 在文档流中只占据所需的空间
- 不能设置宽度和高度
- 只能设置内边距

注意：元素的类型并不是固定的，你可以使用 CSS 的 display 属性来改变元素的类型

## rem 底层是怎么实现的

rem 是参照根目录 HTML 的字体大小
rem 布局实际上就是实现等比缩放
试想，如果我们的元素在不同的屏幕上可以按照相同的比例来进行缩放就好了
rem 的计算原理：
试想把屏幕平均分成 10 份，那么每一份就是 1/10，我们选择每一份的大小是 1rem，那么一个 5\*(1/10)的大小就占屏幕大小的 50%，这就是 rem

---

# JavaScript

## js 数据类型

- 基本数据类型：{% label 'number、string、boolean、null、undefined' green %}
- 引用数据类型：{% label 'object、array' green %}

## 判断数据类型

- {% label 'typeof' pink %}：判断基本数据类型（number、string、boolean）
- {% label 'instanceof' pink %}：判断复杂数据类型（Array，Object，RegExp）
- {% label 'Object.prototype.toString' pink %}：比较全面（缺点：兼容性差）

```js
console.log(typeof num);
console.log(obj instanceof Object);
console.log(Object.prototype.toString.call(null));
```

## var/let/const 的区别

1. const let 是块级作用域；var 没有块级作用域，var 只有函数和全局作用域
2. const let 不存在变量声明的提前，var 有声明的提前，所以 const 和 let 在声明变量/常量 之前，是没办法获取到的，称为暂时性死区 temporal dead zone
3. const let 是 ES6 提出的；var 是 ES5
4. const 声明的是常量，常量不能被修改；let 和 var 声明的是变量，可以被修改
5. const 在声明时必须赋值，而 let 和 var 不需要
6. let 和 const 不能重复声明同一个值，但 var 可以

{% btn 'https://www.bilibili.com/video/BV1qk4y1k75W/?spm_id_from=333.337.search-card.all.click&vd_source=51dc0d76d16e5d6eb2c55984ed42ac56','var let const的区别',far fa-hand-point-right,block green center larger %}

## 闭包

什么是闭包？闭包的作用？闭包的应用？
{% note success no-icon flat %}
➤ 定义：让子函数可以访问父函数中的局部变量
➤ 作用：
（1）保护：避免命名冲突
（2）保存：解决循环绑定引发的索引问题
（3）变量不会销毁：可以使用函数内部的变量，使变量不会被垃圾回收机制回收
➤ 应用：
（1）设计模式中的单例模式
（2）for 循环中的保留 i 的操作
（3）防抖和节流
（4）函数柯里化
➤ 缺点：会出现内存泄漏的问题
{% endnote %}

## 数组中 forEach 和 map 的区别

{% note success no-icon flat %}
● 相同点：循环数组每一项，且都有三个参数，分别是 item、index、array，只是遍历数组，不会改变原数组
● 不同点：
➤ forEach 是将数组中的每一项作为回调函数的参数进行处理
➤ map 返回一个新数组，数组中的元素是调用原数组的方法处理后的值
{% endnote %}

## 深浅拷贝

- 浅拷贝：只复制`引用`，而未复制真正的值。
- 深拷贝：对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连`值`也都复制了。

```js
let obj = {
	name: "陈升",
	family: ["爸爸", "妈妈", "哥哥", "奶奶"],
	hobby: { ball: "篮球" },
};

// 浅拷贝
// 1）扩展运算符
let newObj1 = { ...obj };
// 2）Object.assign(newObj,obj)
let newObj2 = {};
Object.assign(newObj2, obj);
// 3）数组的concat()方法
arr.concat();

// 深拷贝
// 1）利用 JSON 对象中的 parse 和 stringify
let newObj3 = JSON.parse(JSON.stringify(obj));
// 2）利用递归来实现每一层都重新创建对象并赋值
function deepClone(newObj, oldObj) {
	for (let k in oldObj) {
		if (oldObj[k] instanceof Array) {
			newObj[k] = [];
			deepClone(newObj[k], oldObj[k]);
		} else if (oldObj[k] instanceof Object) {
			newObj[k] = {};
			deepClone(newObj[k], oldObj[k]);
		} else {
			newObj[k] = oldObj[k];
		}
	}
}
let newObj4 = {};
deepClone(newObj4, obj);
```

## 防抖和节流

{% note success no-icon flat %}
➤ 防抖：n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时（比如：搜索框的 keyup 事件）
➤ 节流：n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效（比如：发送验证码）
{% endnote %}

{% btn 'https://www.bilibili.com/video/BV1pQ4y1M71e/?spm_id_from=333.337.search-card.all.click&vd_source=51dc0d76d16e5d6eb2c55984ed42ac56',《防抖和节流》视频详解,far fa-hand-point-right,block green center larger %}

## 原型和原型链

{% note success no-icon flat %}
➤ 原型：每个函数都有 prototype 属性，该属性指向原型对象；使用原型对象的好处是所有对象实例共享它所包含的属性和方法。
➤ 原型链：每个对象都拥有一个原型对象，通过**proto** 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。主要解决了继承的问题；
{% endnote %}

{% btn 'https://blog.csdn.net/weixin_43392489/article/details/108456216',《原型和原型链》详解,far fa-hand-point-right,block green center larger %}

## this 指向问题

{% note success no-icon flat %}
➤ `函数`形式调用指向`window`
➤ `方法`形式调用指向`调用对象` (谁调我，我就指向谁)
➤ `构造函数`调用指向它的`实例对象`
➤ `箭头函数`看外层是否有函数，`如果有，外层函数的this就是箭头函数的；如果没有就是window`
{% endnote %}

## 回流和重绘

{% note success no-icon flat %}
概念：
➤ 当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为回流(reflow)。
➤ 当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color，则称为重绘。
区别：
➤ 回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流。
➤ 当页面布局和几何属性改变时就需要回流，比如：添加或者删除可见的 DOM 元素，元素位置改变，元素尺寸改变——边框、填充、宽度和高度，内容改变。
{% endnote %}

## call/bind/apply 的区别

{% note success no-icon flat %}
相同点：
➤ 都是用来`更改函数this指向`的
➤ 这三者的第一个参数都是 this 的新指向
不同点：
➤ 第二个之后的参数`call和bind是直接传入函数值`，而`apply`第二个参数是`数组或伪数组`
➤ bind 方法和其他两种方法的不同点在于，`bind不会执行该函数`，而是返回一个新的函数，`其他方法是直接执行该函数`
{% endnote %}

## new 操作符具体过程

{% note success no-icon flat %}
➤ 创建一个空对象
➤ 将函数的 this 指向给这个空对象
➤ 执行函数代码
➤ 返回该对象
{% endnote %}

## 对 async/await 的理解

{% note success no-icon flat %}
➤ 是异步代码的新方式
➤ 基于 promise 实现的
➤ 使异步代码更像同步代码
➤ await 只能在 async 函数中使用，不能在普通函数中使用，要成对出现
➤ 默认返回一个 promise 实例，不能被改变
➤ await 下面的代码是异步，后面的代码是同步的
{% endnote %}

## promise 的理解

含义：是一种用于异步编程的解决方案，它可以让你以同步的方式编写异步代码。
在 JavaScript 中，很多操作都是异步的，例如网络请求、读取文件或等待用户输入。这些操作会在后台运行，因此你不能直接等待它们完成，而是需要提供一个回调函数，在操作完成时调用。
解决：Promise 可以解决这种回调地狱的问题，它使用一种称为链式调用的方法，让你能够在 then 方法中连续调用多个异步操作。
例如，你可以使用 Promise 发起一个网络请求，然后在请求完成后调用回调函数。你可以使用 then 方法来处理请求结果，如下所示：

```jsx
axios
	.get("http://example.com/movies.json")
	.then((response) => response.json())
	.then((data) => console.log(data))
	.catch((error) => console.error(error));
```

在这个例子中，axios.get 方法会发起一个网络请求，然后返回一个 Promise。你可以在 then 方法中提供一个回调函数来处理响应数据，然后再次使用 then 方法来处理解析后的数据。如果在任何阶段发生错误，你可以使用 catch 方法来处理错误。
这种方法使得异步编程变得更加简单，因为你不再需要写很多嵌套的回调函数。你可以使用 then 方法链式调用多个异步操作，而不用担心回调地狱的问题。
Promise 还有一些其他的特性，例如你可以使用 Promise.all 方法来并行执行多个 Promise，或者使用 Promise.race 方法来执行多个 Promise 中最先完成的那个。你还可以使用 Promise.resolve 和 Promise.reject 方法来创建已完成或已拒绝的 Promise。
总之，Promise 是一种有用的工具，可以让你在异步编程中更加简单、灵活地处理异步操作。

## 对作用域经行说明

## 事件对象和事件委托的说明

## js 事件循环机制中，使用得三种数据对象

## rem 和 em

{% note success no-icon flat %}
{% label em blue %}
➤ 子元素字体大小的 em 是相对于父元素字体大小 font-size
➤ 元素的 width/height/padding/margin 用 em 的话是相对于该元素的 font-size
{% label rem blue %}
rem 是相对长度单位。相对于根元素(即 html 元素)font-size 计算值的倍数的一个 css 单位。
参考：<https://zhuanlan.zhihu.com/p/94369298>
{% endnote %}

## git 命令、git 的工作区有哪些

![](https://csheng-fly.oss-cn-guangzhou.aliyuncs.com/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8.jpg)

## JS 的数据类型，储存上的差距

{% note success no-icon flat %}
数据类型分两大类：

1. **基本数据类型**，变量保存的是**值**
2. **引用数据类型**，变量保存的是**引用地址**
   {% endnote %}

## 跨域怎么处理

{% note success no-icon flat %}

- {% span red, CORS %}：需要后端支持，在响应头中设置可以跨域的参数
- {% span red, 服务器代理 %}(webpack 代理, Nginx 反向代理)：前端系统发布后通常用到这种来解决跨域
- {% span red, JSONP %}：比较老的一种方案，只支持 get 请求，不支持 post 请求
  {% endnote %}

## HTTP 和 HTTPS 区别

{% note success no-icon flat %}

- HTTP 是{% wavy '超文本传输协议，信息是明文传输' %} ; HTTPS 则是具有安全性的 {% wavy 'SSL加密传输协议' %}
- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的{% wavy '端口' %}也不一样，前者是 80，后者是 443
- HTTP 的{% wavy '连接很简单，是无状态的' %} ; HTTPS 协议是由 {% wavy 'SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全' %}
  {% endnote %}

## sessionStorage 和 localStorage 的区别

{% note success no-icon flat %}

1. 功能相似
2. 不同点

- localStorage： 页面关闭数据不丢失，具有{% wavy '永久' %}性质。除非{% wavy '主动删除数据' %}。
- sessionStorage：{% wavy '页面关闭，数据会自动清除' %}

3. 补充：
   cookie：有有效期，可存储 4k 左右的数据，所有同源窗口共享数据，数据携带到请求报文头中传输给服务器端，通常是服务器端通过 set-cookie 的方式来设置存储到浏览器上
   {% endnote %}

## MVVM 的理解

{% note success no-icon flat %}
● Model-View-ViewModel 的简写，即模型-视图-视图模型

- 模型（Model） 指的是后端传递的数据，
- 视图(View)指的是所看到的页面，
- 视图模型(ViewModel)是 mvvm 模式的核心，它是连接 view 和 model 的桥梁

● 有两个方向：

- 将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到 的页面，实现的方式是：数据绑定
- 是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据

● 实现的方式是：DOM 事件监听，这两个方向都实现的，我们称之为数据的双向绑定
{% endnote %}

## MVVM 的优缺点

{% note success no-icon flat %}
优点:

- 实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性
- 提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码
- 能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来

缺点：

- Bug 难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，
  也有可能是 Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，
  要定位原始出问题的地⽅就变得不那么容易了
  可采用的调试方案:
  - (1) 注释掉一段代码, 确定代码的位置
  - (2) debugger 打断点 或者 console 进行调试
- 在⼀个⼤的模块中 Model 也会很⼤，虽然使⽤上来说⽅便了，但如果⻓期持有不释放内存，就会造成更多的(浏览器的)内存消耗
  {% endnote %}

## vue 的优缺点

{% note success no-icon flat %}
优点

1. 数据驱动
2. 组件化
3. 轻量级
4. SPA(单页面)
5. 版本 3.0 的界面化管理工具比较好使
6. vue 易入门
7. 中文社区强大，入门简单，提升也有很多的参考资料。

缺点：

1. 不支持 IE8 及以下浏览器
2. 吃内存（每个组件都会实例化一个 Vue 实例，实例的属性和方法很多）
3. 定义在 data 里面的对象，实例化时，都会递归的遍历转成响应式数据，然而有的响应式数据我们并不会用到，造成性能上的浪费
   {% endnote %}

## ES6 的新增特性

{% note success no-icon flat %}

1. let const
2. 模板字符串
3. 箭头函数
4. Promise、async await
5. class
6. for of
7. Set Map
   {% endnote %}

## CSS3 的新增特性

{% note success no-icon flat %}

1. 伪元素
2. 弹性布局 flex
3. 媒体查询
4. 圆角
5. 渐变
6. 阴影
7. 平面转换
8. 3D 转换
9. 动画
   {% endnote %}

## ES6 中 var、let、const 的区别

{% note success no-icon flat %}
作用：都可以用来声明变量
区别：

- var：存在变量提升、
- let、const:
  - 不存在变量提升
  - 存在暂时性死区
  - 不允许重复声明
- const：声明后不能被修改
  {% endnote %}

## 常见的 HTTP 状态码

{% note success no-icon flat %}

- 2xx：请求成功
- 3xx：重定向
- 4xx：哭护短错误，一般是语法错误或者请求无法实现 --- 403 禁止访问 --- 404 找不到地址的匹配页面
- 5xx：服务器端错误
  {% endnote %}

## 宏任务和微任务

Js 中，有两类任务队列：宏任务队列和微任务队列。
宏任务队列可以有多个，微任务队列只有一个

- 宏任务(task)：setTimeout, setInterval
- 微任务(jobs)：Promise

## 不受同源策略影响的有哪些

除了以下三个资源获取类型的标签，在浏览器中，⼤部分内容都受同源策略限制。
`<img>`
`<link>`
`<script>`

## 改变 this 指向

改变 this 指向的三种方法：call、apply、bind

同：
➤ apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；
➤ apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；
➤ apply 、 call 、bind 三者都可以利用后续参数传参；
异：
bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。

## 数组中 forEach 和 map

forEach 和 map 是 JavaScript 中常用的数组方法，都可以用来遍历数组中的元素，但是它们之间有一些区别：

**功能**不同：

- forEach ：遍历数组，它提供了一种快捷的方式来遍历数组的所有元素。
- map ：映射数组，它可以根据指定的规则对数组的每个元素进行映射，并返回一个新的数组。

**返回值**不同：

- forEach：不会返回任何值，只会对数组的每个元素执行回调函数。
- map：会返回一个新的数组，该数组的元素是对原数组中每个元素执行回调函数之后的返回值。

**处理流程**不同：

- forEach：是按顺序依次对数组的每个元素执行回调函数。
- map：是同时对数组的每个元素执行回调函数，并将结果放入新的数组中。

总的来说，forEach 和 map 是两种常用的数组方法，但是它们的功能、返回值和处理流程都有所不同。根据自己的需要，可以选择适合自己的方法进行使用。

# vue 篇

## MVVM 的理解

MVVM 是一种设计模式，用于将用户界面（UI）与业务逻辑分离。这样可以使 UI 的开发与业务逻辑的开发相互独立，更容易维护和扩展。
MVVM 的名称来自于三个部分：
● Model（模型）：表示应用程序中的数据模型。它代表着应用程序中的业务逻辑和状态。
● View（视图）：表示应用程序的用户界面。它是用户与应用程序交互的方式。
● ViewModel（视图模型）：是一个桥梁，将模型与视图连接在一起。它提供了视图所需的数据和命令，并将用户的输入转换为模型的操作。
通常，ViewModel 通过数据绑定将数据提供给视图，并使用命令处理视图中的用户输入。这样，视图可以直接与 ViewModel 交互，而无需与模型直接交互。这使得视图的开发和模型的开发相互独立，并且可以更轻松地测试和维护应用程序。
MVVM 模式的优点包括：
● 将 UI 和业务逻辑分离，使得 UI 和业务逻辑的开发相互独立。
● 提供了更好的测试支持，因为视图和业务逻辑是分离的，所以可以更轻松地对它们进行单元测试。
● 易于维护和扩展，因为业务逻辑和 UI 分离，所以可以更轻松地更改一个而不会影响另一个。
MVVM 模式也有一些缺点，包括：
● 可能会使代码变得较复杂，因为需要编写数据绑定和命令的代码。
● 可能需要使用特定的框架才能实现 MVVM 模式，例如 Vue 或 Angular。
总的来说，MVVM 是一种有用的设计模式，可以帮助你将用户界面与业务逻辑分离，从而使应用程序更易于维护和扩展。

## 插槽

在 Vue.js 中，插槽（slot）是一种**机制**，可以在父组件的模板中定义一个占位符，然后在子组件中插入内容。这样，子组件就可以在父组件的模板中渲染内容，使得子组件可以更灵活地与父组件进行交互。
插槽有两种类型：

- 具名插槽：具名插槽使用特定的名称来标识，子组件可以插入到特定的插槽中。
- 不具名插槽：不具名插槽没有名称，子组件中的内容会插入到不具名插槽中。

在父组件的模板中，可以使用 <slot> 元素来定义插槽。例如：

```jsx
<template>
	<div class="parent-component">
		<header>
			<slot name="header"></slot>
		</header>
		<main>
			<slot></slot>
		</main>
		<footer>
			<slot name="footer"></slot>
		</footer>
	</div>
</template>
```

在上面的例子中，父组件有三个插槽：一个不具名插槽和两个具名插槽。在子组件中，可以使用 `<template>` 元素来定义要插入的内容。例如：

```jsx
<template>
  <div class="child-component">
    <template #header>
      <h1>这是子组件的头部</h1>
    </template>
    <p>这是子组件的主体内容</p>
    <template #footer>
      <p>这是子组件的底部</p>
    </template>
  </div>
</template>
```

## vue 组件中 data 为什么必须是一个函数

在 Vue.js 中，组件的 data 选项必须是一个函数，这是因为**每个组件实例都应该有自己的状态**，如果 data 不是一个函数，那么所有实例将共享同一个数据对象，这会导致组件之间的状态混乱。
举个例子，假设你有一个组件 A 和组件 B，如果你把 data 写成这样：

```jsx
data: {
	message: "Hello";
}
```

那么组件 A 和组件 B 中的 message 都是同一个值，如果在组件 A 中修改了 message，那么组件 B 中的 message 也会改变。这显然不是你想要的结果。
因此，Vue.js 要求 data 选项必须是一个函数，这样每个组件实例都可以有自己的 data 对象。你可以这样写：

```jsx
data: function () {
  return {
    message: 'Hello'
  }
}
```

这样就能保证每个组件实例都有自己的 data 对象，组件之间的状态就不会混乱了。

## Vue 数据双向绑定的原理

在 Vue.js 中，数据双向绑定是通过使用`观察者模式`来实现的。观察者模式是软件设计模式的一种，它允许对象之间的一对多关系。在这种关系中，一个对象（称为发布者）维护一组依赖于它的对象（称为订阅者），并在其状态更改时通知所有订阅者。
在 Vue.js 中，发布者是 Vue 实例，订阅者是观察者。当 Vue 实例的数据发生变化时，Vue 会通知观察者，观察者会更新视图。这样，当用户在视图中进行操作时，Vue 会更新数据，并通知观察者更新视图。
为了实现数据双向绑定，Vue 使用了一种叫做劫持的技术。劫持就是在数据变化时捕获数据并通知观察者。Vue 实现劫持的方法是使用 Object.defineProperty() 函数，该函数允许在对象的属性被访问或修改时进行拦截。
当 Vue 实例被创建时，它会在内部遍历所有数据并使用 Object.defineProperty() 函数为每个属性添加 getter 和 setter。这样，当数据被访问或修改时，Vue 就可以捕获数据并通知观察者。
例如，当你在 Vue 实例中声明一个属性 message：

```jsx
var app = new Vue({
	el: "#app",
	data: {
		message: "Hello Vue!",
	},
});
```

Vue 会使用 Object.defineProperty() 函数为 message 属性添加 getter 和 setter，这样在访问或修改 message 属性时，Vue 就可以捕获数据并通知观察者。
当视图中的数据改变时，Vue 会使用 setter 通知观察者。观察者会更新视图，而用户在视图中的操作会使用 getter 更新数据。这样，数据和视图之间就形成了双向绑定。

## 自己举一个使用 vuex 的完整过程

1. 安装 Vuex：使用 npm 或 yarn 安装 Vuex。

```jsx
npm install vuex
```

2. 创建 store：创建一个 store.js 文件，并在文件中定义 store 的状态、getters、mutations 和 actions。

```jsx
import Vue from "vue";
import Vuex from "vuex";

Vue.use(Vuex);

export default new Vuex.Store({
	state: {
		// 定义状态
	},
	getters: {
		// 定义 getters
	},
	mutations: {
		// 定义 mutations
	},
	actions: {
		// 定义 actions
	},
});
```

3. 在入口文件中加载 store：在应用的入口文件中引入 store.js 文件，并将 store 实例作为参数传递给 new Vue()。

```jsx
import Vue from "vue";
import App from "./App.vue";
import store from "./store";

new Vue({
	store,
	render: (h) => h(App),
}).$mount("#app");
```

在组件中使用 Vuex：在组件中使用 $store 访问 store 中的状态、getters、mutations 和 actions。

```jsx
export default {
	computed: {
		// 使用 getters
		count() {
			return this.$store.getters.count;
		},
	},
	methods: {
		// 使用 mutations
		increment() {
			this.$store.commit("increment");
		},
		// 使用 actions
		asyncIncrement() {
			this.$store.dispatch("asyncIncrement");
		},
	},
};
```

## 递归

递归是一种编程技术，允许**函数调用自身**。这种技术可用于解决一些复杂的问题，并且通常比循环更简洁易懂。
举个例子，假设你想要计算某个数的阶乘。阶乘是一个数的所有自然数的乘积，如 5 的阶乘为 5 _ 4 _ 3 _ 2 _ 1。
你可以使用递归来实现这个函数，具体方法是：
● 如果这个数小于等于 1，则返回 1。
● 否则，返回这个数乘上它的（n-1）的阶乘。
这样，每次调用函数时，它就会调用自身，直到数字小于等于 1，然后开始返回结果。
递归还有很多其他应用场景，例如：
● 计算斐波那契数列的某一项。
● 在数据结构中，例如二叉树或链表，递归可以用来遍历整个数据结构。
● 在排序算法中，递归可以用来实现快速排序或归并排序。
总的来说，递归是一种非常有用的编程技术，能帮助你解决一些复杂的问题。但同时，也要注意**递归程序可能会占用大量的内存**，因此要谨慎使用。

## v-model 实现的原理

在 Vue.js 中，v-model 指令是一种语法糖，它的作用是为表单元素绑定双向数据绑定。
这意味着当用户输入表单元素时，它会更新 Vue 实例的数据，同时也会将 Vue 实例中的数据反映到表单元素上。
例如，如果你想要在 Vue 实例中绑定一个输入框的值，你可以使用 v-model 指令：

```jsx
<template>
  <input v-model="message">
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, world!'
    }
  }
}
</script>
```

实现原理
v-model 指令的实现原理是基于计算属性和事件绑定。它会将表单元素的 value 属性绑定到一个计算属性上，并且在计算属性的 setter 中触发 input 事件来更新 Vue 实例中的数据。
例如，上面的代码实际上等价于：

```jsx
<template>
  <input :value="message" @input="message = $event.target.value">
</template>

<script>
export default {
  data() {
    return {
      message: 'Hello, world!'
    }
  }
}
</script>
```

这样，当用户在输入框中输入文本时，输入框的 value 属性会被更新

## 单页面应用

单页面应用（Single-Page Application，简称 SPA）是一种架构方式，它在一个单独的网页中加载所有的资源，并使用 JavaScript 在客户端渲染用户界面，而不是通过服务器进行渲染。这意味着，当用户在 SPA 应用中导航到不同的页面时，不会发生实际的页面跳转，而是在当前页面内使用 JavaScript 更新内容。这使得 SPA 应用的体验非常流畅，因为不会有页面加载的延迟。
与传统的多页面应用相比，单页面应用具有许多优势，包括：

- 快速响应：由于不需要重新加载页面，因此 SPA 应用可以快速响应用户的操作。
- 减少服务器负载：由于大部分的处理都是在客户端进行的，因此 SPA 应用可以减少服务器的负载。
- 更好的用户体验：由于 SPA 应用的页面切换非常流畅，因此它可以提供更好的用户体验。

然而，单页面应用也有一些缺点，包括：

- 较难调试：由于 SPA 应用的代码都在客户端运行，因此调试可能会更加困难。
- SEO 难度较大：对于单页面应用，搜索引擎爬虫可能无法正常抓取页面内容，因此 SPA 应用的 SEO 较为困难。为了解决这个问题，可以使用服务端渲染（Server-Side Rendering，简称 SSR）技术，在服务器端渲染 SPA 应用的内容，使得爬虫可以正常抓取页面内容。

总的来说，单页面应用是一种有效的架构方式，它可以提供流畅的用户体验，但在 SEO 和离线使用方面存在一定的困难。

## vue 的理解

1. Vue.js 是一个渐进式的 JavaScript 框架，旨在通过尽可能简单的 API 实现响应式数据绑定和组合的视图组件。
2. Vue.js 的核心是一个叫做 Vue 实例的 JavaScript 对象，该对象用于控制一个 HTML 页面中的一个区域，称为“视图”。Vue 实例可以通过声明式模板或使用 JavaScript 代码动态渲染视图。
3. Vue.js 的响应式系统使得在模型数据变化时，视图会自动更新。这意味着，你可以在不手动操作 DOM 的情况下改变视图。Vue.js 还提供了许多其他功能，如组件系统、路由、状态管理等，可以帮助你构建复杂的单页应用。
4. 总的来说，Vue.js 是一个轻量级的、易于使用的前端框架，可以帮助你快速构建响应式的 Web 应用。

## vue.js 中如何监听路由信息的改变

{% tabs 'vue.js 中如何监听路由信息的改变' %}

<!-- tab 通过 watch 监听 -->

```jsx
// 监听,当路由发生变化的时候执行
watch:{
  $route(to,from){
    console.log(to.path);
  }
},
或者
// 监听,当路由发生变化的时候执行
watch: {
  $route: {
    handler: function(val, oldVal){
      console.log(val);
    },
    // 深度观察监听
    deep: true
  }
},
或者
// 监听,当路由发生变化的时候执行
watch: {
  '$route':'getPath'
},
methods: {
  getPath(){
    console.log(this.$route.path);
  }
}
```

<!-- endtab -->

<!-- tab 通过路由钩子函数监听 -->

```jsx
<script>
  export default {
    name: 'app',
    // 监听,当路由发生变化的时候执行
    beforeRouteEnter (to, from, next) {
      // 在渲染该组件的对应路由被 confirm 前调用
      // 不！能！获取组件实例 `this`
      // 因为当钩子执行前，组件实例还没被创建
    },
    beforeRouteUpdate (to, from, next) {
      // 在当前路由改变，但是该组件被复用时调用
      // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
      // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
      // 可以访问组件实例 `this`
    },
    beforeRouteLeave (to, from, next) {
      // 导航离开该组件的对应路由时调用
      // 可以访问组件实例 `this`
    }
</script>
```

<!-- endtab -->

{% endtabs %}

## nextTick 的理解

nextTick 是 Vue.js 中一个用来在下一个事件循环中调用回调函数的方法。这个方法通常用在等待数据或 DOM 元素更新之后执行一些代码的情况下。
举个例子，假设你有一个组件，它的模板中使用了一个计算属性 fullName，该计算属性由组件中的 firstName 和 lastName 两个数据项拼接而成：

```jsx
<template>
  <div>{{ fullName }}</div>
</template>

<script>
export default {
  data() {
    return {
      firstName: 'John',
      lastName: 'Doe'
    }
  },
  computed: {
    fullName() {
      return `${this.firstName} ${this.lastName}`
    }
  }
}
</script>
```

假设你想要在更新 firstName 和 lastName 后执行一些代码，但你发现 Vue 的计算属性是同步的，所以你无法在计算属性更新之后立即执行代码。这时你就可以使用 nextTick 方法：

```jsx
this.firstName = "Jane";
this.lastName = "Doe";

this.$nextTick(() => {
	// 在这里执行代码
	console.log(this.fullName);
});
```

这样你就可以在计算属性更新之后执行代码了。
你可能会在组件的生命周期钩子函数 created 中使用 nextTick，因为在该钩子函数中组件的模板还没有被渲染，但是你想要在模板渲染之后执行一些代码：

```jsx
export default {
	created() {
		this.$nextTick(() => {
			// 在这里执行代码
			console.log("模板已经渲染完成");
		});
	},
};
```

## vue 给对象添加新属性界面不刷新

```jsx
<template>
  <div id="app">
    {{ obj }} <br />
    <button @click="addProperty">动态添加新属性</button>
  </div>
</template>

<script>
export default {
  name: "App",
  data() {
    return {
      obj: { oldProperty: "旧值" },
    };
  },
  methods: {
    addProperty() {
      this.obj.newProperty = "新值";
      console.log(this.obj); // 在浏览器输出的是最新结果，但是页面视图并没有更新
    },
  },
};
</script>
<style lang="less"></style>
```

原因：Vue 不允许在已经创建的实例上，动态添加新的响应式属性；
三种解决办法：

1. 使用 Vue.set( target , key , value)
2. 使用$fourceUpdate 强制刷新
3. 克隆新对象，如 this.persons ={...this.persons}， this.persons = Object.assign({}, this.persons)

```jsx
    addProperty() {
      // 方法一：使用Vue.set(target, key, value)
      this.$set(this.obj, "newProperty", "新值");

      // 方法二：$forceUpdate迫使Vue实例重新渲染（不建议使用）
      this.obj.newProperty = "新值";
      this.$forceUpdate();

      // 方法三：克隆新对象
      this.obj = { ...this.obj, newProperty: "新值" };

      console.log(this.obj); // 在浏览器输出的是最新结果，但是页面视图并没有更新
    },
```

## 之前有用到 Vue 2.几的版本

在命令面板中输入：`npm view vue versions` 就可以查看到所有可用的 vue 版本
截止到 2022 年 7 月 30 日
vue2 最新的版本是：2.7.8
vue3 最新的版本是：3.2.37

## vue 中 key 的原理

在 Vue.js 中，当使用 v-for 指令渲染一个列表的时候，Vue.js 强制要求使用 key 属性来提高性能。这个 key 属性是 Vue.js 内部使用的，它并不会对你的应用造成任何影响。
在 Vue.js 内部，使用 key 属性可以帮助 Vue.js 识别列表中的每个元素。这样 Vue.js 就可以更快地更新列表中的元素，因为它可以直接找到要更新的元素，而不是遍历整个列表来寻找需要更新的元素。
使用 key 属性的方法是在每个 v-for 指令的模板中给每个元素添加一个唯一的 key 属性，如下所示：

```jsx
<div v-for="item in items" :key="item.id">{{ item.text }}</div>
```

在上面的例子中，Vue.js 会使用每个元素的 id 属性作为 key 属性。你可以使用任何唯一的值作为 key 属性，只要它能唯一标识列表中的每个元素即可。
总的来说，使用 key 属性可以帮助 Vue.js 更快地更新列表中的元素，提高应用的性能。

## Vue 组件通讯

● 父传子：子组件定义 props 属性接收
● 子传父：子组件中使用 this.$emit方法
● 兄弟传值：事件总线，$on 方法
● 父传孙：provide 和 inject 方式

## 兄弟组件的传值

1. 使用 eventBus，跨组件通信
2. 借鉴 React，使用状态提升
3. 使用 Vuex

## 自定义指令的使用以及生命周期/钩子函数

● 分类：全局自定义指令，局部自定义指令
● 全局自定义指令：

```jsx
Vue.directive("指令名", {
	// 当被绑定的元素插入到 DOM 中时……
	inserted: function (el) {
		// 操作
	},
});
```

局部自定义指令：

```jsx
directives: {
  指令名: {
    // 指令的定义
    inserted: function (el) {
       // 操作
    }
  }
}
```

● 生命周期/钩子函数：
○ inserted：被绑定元素插入父节点时调用
○ bind：只调用一次，指令第一次被绑定到元素时
○ update：元素本身更新时触发
○ componentUpdate：组件和子组件更新时触发
○ unbind：指令被移除时触发
● 每个钩子函数中都有 el 和 binding 参数，而 componentUpdate 钩子中还暴露一个 oldVal，用以区分旧值和新值
○ el：绑定元素
○ binding：是一个参数对象，一般我们会用到其中的 value 值，用于 src 的属性值

## 说 5 个 vue 的指令

1. v-bind：绑定属性
2. v-if 、v-show：条件渲染
3. v-for： 列表渲染
4. v-model：双向绑定
5. v-html：解析 html 字符串
6. v-on：绑定事件

## 路由懒加载

在 Vue.js 中，懒加载可以帮助你减小应用的初始加载大小，并在路由被访问时再加载对应的组件。这可以通过使用 Vue 的异步组件和 Webpack 的代码分割功能来实现。
首先，你需要将你的组件定义为异步组件，这意味着它不是立即加载的，而是在被访问时才加载。你可以使用 Vue 的 component 属性提供一个工厂函数来实现这一点，例如：

```jsx
const SomeComponent = () => ({
	// 这个组件会在被访问时异步加载
	component: import("./some-component.vue"),
	loading: SomeLoadingComponent,
	error: SomeErrorComponent,
	delay: 200,
	timeout: 3000,
});
```

接下来，你可以在路由配置中使用这个异步组件。例如：

```jsx
const router = new VueRouter({
	routes: [
		{
			path: "/some-route",
			component: SomeComponent,
		},
	],
});
```

这样，当你访问 /some-route 时，组件 some-component.vue 就会被异步加载，而不是在应用初始加载时一并加载。
注意，上面的例子假设你已经使用了 Webpack 和 vue-loader，并且在 Webpack 配置中启用了代码分割功能。这样，Webpack 就会将组件分割成独立的包，并在被访问时动态加载。

## Vuex 核心属性

● state：定义需要管理的数据
● getters：state 派生出来的数据，相当于 state 的计算属性
● mutation：里面定义的是同步的更新数据方法，每个方法里都有两个参数，一个是 state，一个是 payload，通过 store.commit 调用
● action：里面定义的是异步的方法，每个方法里面有两个参数，一个是 store，一个是 payload，通过 store.dispatch 调用，在 actions 里也可以提交 mutation，通过 store.commit
● module：将 vuex 模块化，可以让每一个模块拥有自己的 state、mutation、action、getters，结构清晰，方便管理

## 路由模式

● hash 模式：
○ 浏览器中符号是“#”，#以及#后面的字符称之为 hash，又叫前端路由
○ 用 window.location.hash 读取
○ hash 虽然在 URL 中，但不被包括在 HTTP 请求中
○ hash 改变会触发 hashchange 事件
○ hash 发生变化的 url 都会被浏览器记录下来，从而浏览器的前进后退都可以用
● history 模式：
○ history 采用 HTML5 的新特性
○ history 模式不仅可以在 url 里放参数，还可以将数据存放在一个特定的对象中
○ 它也有个问题：不怕前进，不怕后退，就怕刷新（如果后端没有准备的话，会分分钟刷出一个 404 来），因为刷新是实实在在地去请求服务器的

## 路由之间跳转方式

● 四种方式：
○ router-link 搭配 to 属性，在模板中使用
○ push()跳转到指定页面
○ replace()跳转到指定页面，但是没有历史记录跳不回去
○ go(N)N 可以为正数也可以为负数，正数是向前跳转，负数是向后跳转

## 如何封装组件

● 原因：封装组件可以提升项目开发效率，把页面抽象成多个相对独立的模块，复用性高
● 步骤：
○ 创建一个组件
○ Vue.component 注册组件
○ 子组件需要数据，可以在 props 中接受定义
○ 而子组件修改好数据后，想把数据传递给父组件，可以采用 emit 方法

## v-show 和 v-if 的区别

作用：添加渲染，切换显示与隐藏
不同：v-if 会移除 dom 或组件树，v-show 则只是通过样式隐藏
场景：

1. v-if：切换不频繁、敏感数据的隐藏（如权限按钮）
2. v-show：切换频繁的场景

## v-for 和 v-if 为什么不能一起使用

【回答此句-良好】在 vue2 中 v-for 优先级高于 v-if，如果二者放在同一级标签里面，每次都要先循环，再判断，消耗很多性能。
【回答此句-优秀】对于同一组数据来说，如果我们要先判断再渲染，可以在外层包装一个 div，使用 v-if 做一次判断即可。Vue3 解决了这个问题，将 v-if 的优先级调整为高于 v-for 了。

## 说说 vue 的生命周期

好的，这个问题其实是这样的：
【必须回答】Vue 中的生命周期本质上就是按顺序固定执行一个个的钩子函数，我们开发者可以在每个函数中写入特定代码来实现我们需要的功能
例如我们常用的 ajax 请求通常就放在 created 或者 mounted 中
------回答标准：以下分类能说出几个就是几个，这样就是到了回答良好的标准，但是不能一个都说不出来，-----

vue2 的生命周期从分类上来看有如下几种情况：

1.  组件创建和挂载相关的钩子函数有
    a. beforeCreate
    b. created
    c. beforeMount
    d. mounted
2.  组件更新相关的钩子函数有
    a. beforeUpdate
    b. updated
3.  组件销毁相关的钩子函数有
    a. beforeDestroy
    b. destroyed

【以下如果能回答出来是超过面试官预期的，更加优秀】

1. 还有一个组件缓存激活相关的钩子函数是：activated 和 deactivated，这两个要配合 keep-alive 缓存的组件一起使用
2. vue3 总体来说什么周期执行顺序是一样的，不同点在于 beforeCreate 和 created 都被 setup 函数替代了
   参考链接：https://cn.vuejs.org/v2/api/#activated

## Vue 组件之间的传递方式

Vue 组件之间数据传递的几种方式:
[回答第 1,2 条-合格，因为是常用的]

1. 父组件向子组件传递数据，使用 props 属性；子组件向父组件中传递数据，在子组件中使用$emit 派发事件，父组件中使用 v-on 监听事件。缺点:组件嵌套层次多的话，传递数据比较麻烦。
2. 通过 Vuex，实现多个组件进行数据共享，推荐使用这种方式进行项目中各组件间的数据传递。
   [如果还能将第 3 条回答出-良好]
3. 通过事件总线(eventbus)的方式，可以实现任意两个组件间进行数据传递;缺点:不支持响应式，这个概念是 vue1.0 版本中的，现在已经废弃
   [如果还能将第 4,5 条回答出-优秀]
4. 祖先组件通过依赖注入(inject/provide)的方式，向其所有子孙后代传递数据;缺点:无法监听数据修改的来源，不支持响应式。
5. 通过属性 parent/$children/ref，访问根组件、父级组件、子组件中的数据;缺点:要求组件之间要有传递性。

## vue-router 的钩子函数

## 单页面应用-SSR 服务器渲染

> 在服务端 html 页面，节点已经解析创建完了，浏览器直接拿到的是解析完成的页面结构

优：更好的 SEO，因为搜索引擎爬虫抓取工具可以直接查看完全渲染的页面
缺：服务器 nodejs 环境的要求，且对源代码的改造成本高！（nuxt.js 的坑比较多，做好踩坑的准备）

## 单页面应用-静态化

Nuxt.js 可以进行 generate 静态化打包，缺点：动态路由会被忽略（如 /user/:id）

优势：

- 编译打包时，就会帮你处理，纯静态文件，访问速度超快
- 对比 SSR，不涉及到服务器负载方面问题
- 静态网页不容易遭到黑客攻击，安全性更高

缺点：

- 如果动态路由参数多的话不适用

# 性能提升

## innerText 和 textContent 的区别

- 设置文本替换时，两者都会把指定节点下的所有子节点也一并替换掉。
- textContent 会获取所有元素的内容，包括 `<script>` 和 `<style>` 元素，然而 innerText 不会。
- innerText 受 CSS 样式的影响，并且不会返回隐藏元素的文本，而 textContent 会。
- 由于 innerText 受 CSS 样式的影响，它会触发回流重排（reflow），但 textContent 不会。
- innerText 不是标准制定出来的 api，而是 IE 引入的，所以对 IE 支持更友好。
- textContent 虽然作为标准方法但是只支持 IE8+以上的浏览器，在最新的浏览器中，两个都可以使用。
  综上，Vue 这里使用 textContent 是从性能的角度考虑的。
  从性能上考虑的话，textContent 的性能的确要比 innerText 的执行效率要高
