---
title: 前端面试题
date: 2022-11-28 00:00:00
categories: "面试"
description: 摘录一些面试中遇到的高频前端面试题（持续更新中）
cover: https://csheng-fly.oss-cn-guangzhou.aliyuncs.com/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98.png
toc_number: false
sticky: 1
---

# HTML/CSS
## css选择器权重值
- !important > 行内元素 > ID选择器 > 类选择器 > 标签 > 通配符

## HTML5/CSS3的新特性
{% tabs test %}
<!-- tab HTML5的新特性 -->
- 只有一种 DOCTYPE ⽂件类型声明(统 一标准)：`<!DOCTYPE html>`
- 增加了一些新的标签元素(功能, 语义化）：section, footer, header, nav
- input 支持了几个新的类型值：date, email, url 等等
- 新增了一些标签属性：charset（⽤于 meta 标签）；async（⽤于 script 标 签）
- 新增的全域属性：contenteditable, draggable... hidden...
- 新增API：本地存储, 地理定位, Canvas绘图, 拖拽API, 即时通信 WebSocket
<!-- endtab -->

<!-- tab CSS3的新特性 -->
- 伪元素
- 弹性布局flex
- 媒体查询
- 圆角
- 渐变
- 阴影
- 平面转换
- 3D转换
- 动画
<!-- endtab -->
{% endtabs %}

---
# JavaScript
## js数据类型
- 基本数据类型：{% label 'number、string、boolean、null、undefined' green %}
- 引用数据类型：{% label 'object、array' green %}

## 判断数据类型
- {% label 'typeof' pink %}：判断基本数据类型（number、string、boolean）
- {% label 'instanceof' pink %}：判断复杂数据类型（Array，Object，RegExp）
- {% label 'Object.prototype.toString' pink %}：比较全面（缺点：兼容性差）

```js
console.log(typeof num);
console.log(obj instanceof Object);
console.log(Object.prototype.toString.call(null));
```


## var/let/const 的区别
1. const let 是块级作用域；var没有块级作用域，var只有函数和全局作用域
2. const let 不存在变量声明的提前，var有声明的提前，所以const和let在声明变量/常量 之前，是没办法获取到的，称为暂时性死区 temporal dead zone
3. const let 是 ES6 提出的；var 是 ES5
4. const 声明的是常量，常量不能被修改；let和 var声明的是变量，可以被修改
5. const 在声明时必须赋值，而let和var不需要
6. let 和 const 不能重复声明同一个值，但var可以

{% btn 'https://www.bilibili.com/video/BV1qk4y1k75W/?spm_id_from=333.337.search-card.all.click&vd_source=51dc0d76d16e5d6eb2c55984ed42ac56','var let const的区别',far fa-hand-point-right,block green center larger %}

## 闭包
什么是闭包？闭包的作用？闭包的应用？
{% note success no-icon flat %}
➤ 定义：让子函数可以访问父函数中的局部变量
➤ 作用：
	（1）保护：避免命名冲突
	（2）保存：解决循环绑定引发的索引问题
	（3）变量不会销毁：可以使用函数内部的变量，使变量不会被垃圾回收机制回收
➤ 应用：
	（1）设计模式中的单例模式
	（2）for循环中的保留i的操作
	（3）防抖和节流
	（4）函数柯里化
➤ 缺点：会出现内存泄漏的问题
{% endnote %}

## 数组中forEach和map的区别
{% note success no-icon flat %}
● 相同点：循环数组每一项，且都有三个参数，分别是item、index、array，只是遍历数组，不会改变原数组
● 不同点： 
  ➤ forEach是将数组中的每一项作为回调函数的参数进行处理
  ➤ map返回一个新数组，数组中的元素是调用原数组的方法处理后的值
{% endnote %}

## 深浅拷贝
- 浅拷贝：只复制`引用`，而未复制真正的值。
- 深拷贝：对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连`值`也都复制了。

```js
let obj = {
	name: '陈升',
	family: ['爸爸', '妈妈', '哥哥', '奶奶'],
	hobby: { ball: '篮球' },
};

// 浅拷贝
// 1）扩展运算符
let newObj1 = { ...obj };
// 2）Object.assign(newObj,obj)
let newObj2 = {};
Object.assign(newObj2, obj);
// 3）数组的concat()方法
arr.concat()

// 深拷贝
// 1）利用 JSON 对象中的 parse 和 stringify
let newObj3 = JSON.parse(JSON.stringify(obj));
// 2）利用递归来实现每一层都重新创建对象并赋值
function deepClone(newObj, oldObj) {
	for (let k in oldObj) {
		if (oldObj[k] instanceof Array) {
			newObj[k] = [];
			deepClone(newObj[k], oldObj[k]);
		} else if (oldObj[k] instanceof Object) {
			newObj[k] = {};
			deepClone(newObj[k], oldObj[k]);
		} else {
			newObj[k] = oldObj[k];
		}
	}
}
let newObj4 = {};
deepClone(newObj4, obj);
```


## 防抖和节流
{% note success no-icon flat %}
➤ 防抖：n秒后在执行该事件，若在n秒内被重复触发，则重新计时（比如：搜索框的keyup事件）
➤ 节流：n秒内只运行一次，若在n秒内重复触发，只有一次生效（比如：发送验证码）
{% endnote %}

{% btn 'https://www.bilibili.com/video/BV1pQ4y1M71e/?spm_id_from=333.337.search-card.all.click&vd_source=51dc0d76d16e5d6eb2c55984ed42ac56',《防抖和节流》视频详解,far fa-hand-point-right,block green center larger %}

## 原型和原型链
{% note success no-icon flat %}
➤ 原型：每个函数都有 prototype 属性，该属性指向原型对象；使用原型对象的好处是所有对象实例共享它所包含的属性和方法。
➤ 原型链：每个对象都拥有一个原型对象，通过__proto__ 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。主要解决了继承的问题；
{% endnote %}

{% btn 'https://blog.csdn.net/weixin_43392489/article/details/108456216',《原型和原型链》详解,far fa-hand-point-right,block green center larger %}

## this指向问题
{% note success no-icon flat %}
➤ `函数`形式调用指向`window`
➤ `方法`形式调用指向`调用对象` (谁调我，我就指向谁)
➤ `构造函数`调用指向它的`实例对象`
➤ `箭头函数`看外层是否有函数，`如果有，外层函数的this就是箭头函数的；如果没有就是window`
{% endnote %}

## 回流和重绘
{% note success no-icon flat %}
概念：
➤ 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为回流(reflow)。
➤ 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color，则称为重绘。
区别：
➤ 回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流。
➤ 当页面布局和几何属性改变时就需要回流，比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边框、填充、宽度和高度，内容改变。
{% endnote %}

## call/bind/apply的区别
{% note success no-icon flat %}
相同点：
➤ 都是用来`更改函数this指向`的
➤ 这三者的第一个参数都是this的新指向
不同点：
➤ 第二个之后的参数`call和bind是直接传入函数值`，而`apply`第二个参数是`数组或伪数组`
➤ bind方法和其他两种方法的不同点在于，`bind不会执行该函数`，而是返回一个新的函数，`其他方法是直接执行该函数`
{% endnote %}

## new操作符具体过程
{% note success no-icon flat %}
➤ 创建一个空对象
➤ 将函数的this指向给这个空对象
➤ 执行函数代码
➤ 返回该对象
{% endnote %}

## 对async/await的理解
{% note success no-icon flat %}
➤ 是异步代码的新方式
➤ 基于promise实现的
➤ 使异步代码更像同步代码
➤ await 只能在async函数中使用，不能在普通函数中使用，要成对出现
➤ 默认返回一个promise实例，不能被改变
➤ await下面的代码是异步，后面的代码是同步的
{% endnote %}

## 如何理解promise?
## 对作用域经行说明
## 事件对象和事件委托的说明
## js事件循环机制中，使用得三种数据对象
## rem和em
{% note success no-icon flat %}
{% label em blue %}
➤ 子元素字体大小的em是相对于父元素字体大小font-size
➤ 元素的width/height/padding/margin用em的话是相对于该元素的font-size
{% label rem blue %}
rem是相对长度单位。相对于根元素(即html元素)font-size计算值的倍数的一个css单位。
参考：<https://zhuanlan.zhihu.com/p/94369298>
{% endnote %}

## git命令、git的工作区有哪些
![](https://csheng-fly.oss-cn-guangzhou.aliyuncs.com/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8.jpg)

## JS的数据类型，储存上的差距
{% note success no-icon flat %}
数据类型分两大类：
1. **基本数据类型**，变量保存的是**值**
2. **引用数据类型**，变量保存的是**引用地址**
{% endnote %}  

## 跨域怎么处理
{% note success no-icon flat %}
- {% span red, CORS %}：需要后端支持，在响应头中设置可以跨域的参数
- {% span red, 服务器代理 %}(webpack代理, Nginx反向代理)：前端系统发布后通常用到这种来解决跨域
- {% span red, JSONP %}：比较老的一种方案，只支持get请求，不支持post请求
{% endnote %}  

## HTTP和HTTPS区别
{% note success no-icon flat %}
- HTTP 是{% wavy '超文本传输协议，信息是明文传输' %} ; HTTPS则是具有安全性的 {% wavy 'SSL加密传输协议' %}
- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的{% wavy '端口' %}也不一样，前者是80，后者是443
- HTTP 的{% wavy '连接很简单，是无状态的' %} ; HTTPS 协议是由 {% wavy 'SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全' %}
{% endnote %}  

## sessionStorage和localStorage的区别
{% note success no-icon flat %}
1. 功能相似
2. 不同点
  - localStorage： 页面关闭数据不丢失，具有{% wavy '永久' %}性质。除非{% wavy '主动删除数据' %}。
  - sessionStorage：{% wavy '页面关闭，数据会自动清除' %}
3. 补充：
cookie：有有效期，可存储4k左右的数据，所有同源窗口共享数据，数据携带到请求报文头中传输给服务器端，通常是服务器端通过set-cookie的方式来设置存储到浏览器上
{% endnote %}

## MVVM的理解
{% note success no-icon flat %}
● Model-View-ViewModel 的简写，即模型-视图-视图模型
- 模型（Model） 指的是后端传递的数据，
- 视图(View)指的是所看到的页面，
- 视图模型(ViewModel)是 mvvm 模式的核心，它是连接 view 和 model 的桥梁

● 有两个方向： 
- 将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到 的页面，实现的方式是：数据绑定
- 是将视图(View)转化成模型(Model)，即将所看到的页面转化成后端的数据

● 实现的方式是：DOM 事件监听，这两个方向都实现的，我们称之为数据的双向绑定
{% endnote %}

## MVVM的优缺点
{% note success no-icon flat %}
优点:
- 实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性
- 提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码
- 能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来

缺点：
- Bug 难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，
也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，
要定位原始出问题的地⽅就变得不那么容易了
可采用的调试方案:
   - (1) 注释掉一段代码, 确定代码的位置
   - (2) debugger 打断点 或者 console 进行调试 
- 在⼀个⼤的模块中 Model 也会很⼤，虽然使⽤上来说⽅便了，但如果⻓期持有不释放内存，就会造成更多的(浏览器的)内存消耗 
{% endnote %}

## vue的优缺点
{% note success no-icon flat %}
优点
1. 数据驱动
2. 组件化
3. 轻量级
4. SPA(单页面)
5. 版本3.0的界面化管理工具比较好使
6. vue易入门
7. 中文社区强大，入门简单，提升也有很多的参考资料。

缺点：
1. 不支持IE8及以下浏览器
2. 吃内存（每个组件都会实例化一个Vue实例，实例的属性和方法很多）
3. 定义在data里面的对象，实例化时，都会递归的遍历转成响应式数据，然而有的响应式数据我们并不会用到，造成性能上的浪费
{% endnote %}

## ES6的新增特性
{% note success no-icon flat %}
1. let const
2. 模板字符串
3. 箭头函数
4. Promise、async await
5. class
6. for of
7. Set Map
{% endnote %}

## CSS3的新增特性
{% note success no-icon flat %}
1. 伪元素
2. 弹性布局flex
3. 媒体查询
4. 圆角
5. 渐变
6. 阴影
7. 平面转换
8. 3D转换
9. 动画
{% endnote %}

## ES6中var、let、const的区别
{% note success no-icon flat %}
作用：都可以用来声明变量
区别：
- var：存在变量提升、 
- let、const: 
  - 不存在变量提升
  - 存在暂时性死区
  - 不允许重复声明
- const：声明后不能被修改
{% endnote %}

## 常见的HTTP状态码
{% note success no-icon flat %}
- 2xx：请求成功
- 3xx：重定向
- 4xx：哭护短错误，一般是语法错误或者请求无法实现 --- 403 禁止访问 --- 404 找不到地址的匹配页面
- 5xx：服务器端错误
{% endnote %}

# vue 
## v-for中key的作用
{% note success no-icon flat %}

对于用<font color=red>v-for渲染的列表数据</font>来说，数据量一般很庞大，而且我们经常还要对这个数据进行一些增删改操作。那么整个列表都要重新进行渲染一遍，那样就会<font color=red>很费性能</font>。而<font color=red>key的出现</font>就尽可能的回避这个问题，<font color=red>提高效率</font>。<br/>
v-for默认使用<font color=red>就地复用的策略</font>，列表数据修改的时候，它会<font color=red>根据key值去判断某一个值是否修改，如果修改则重新渲染该项，否则复用之前的元素</font>。在v-for中我们的key一般为id，也就是唯一的值，但是一般不要使用index作为key，因为index的值会重复。
{% endnote %}

## 说5个vue的指令
{% note success no-icon flat %}
<font size = 5>
1. v-bind：绑定属性 <br/>
2. v-if 、v-show：条件渲染 <br/>
3. v-for： 列表渲染 <br/>
4. v-model：双向绑定 <br/>
5. v-html：解析html字符串 <br/>
6. v-on：绑定事件
</font>

{% endnote %}


## v-model 的实现原理
{% note success no-icon flat %}
- 以value和input值为例，其实是:value和@input的语法糖
- :value是绑定了数据，@input是监听输入框值的变化，然后改变值
- 总的来说就是绑定数据并且监听数据改变
- 内部为不用的输入元素使用不用的属性并抛出不同的事件：
  - text和textarea使用value属性和input事件
  - checkbox使用checked和change事件
  - select将value作为props并将change作为事件
{% endnote %}

## v-show和v-if的区别
{% note success no-icon flat %}
作用：添加渲染，切换显示与隐藏
不同：v-if会移除dom或组件树，v-show则只是通过样式隐藏
场景：
1. v-if：切换不频繁、敏感数据的隐藏（如权限按钮）
2. v-show：切换频繁的场景
{% endnote %}

## v-for和v-if为什么不能一起使用
{% note success no-icon flat %}
在vue2中v-for<font color=red>优先级</font>高于v-if，如果二者放在同一级标签里面，每次都要先循环，再判断，消耗很多性能。
对于同一组数据来说，如果我们要先判断再渲染，可以在外层包装一个div，使用v-if做一次判断即可。Vue3解决了这个问题，将v-if的优先级调整为高于v-for了。
{% endnote %}

## diff算法
![](https://csheng-fly.oss-cn-guangzhou.aliyuncs.com/vue%E7%9A%84diff%E7%AE%97%E6%B3%95.png)

## watch深度侦听和立即侦听
{% note success no-icon flat %}
1. deep（深度侦听）：默认情况下，侦听器无法侦听对象的属性值的变化，如果想实现这个效果，则需要添加deep配置为true
2. <u>handler（固定方法触发）：因为你要添加deep的配置，所以，侦听器的形式要变更为对象形式，只有对象才能添加其它的配置, 同时侦听函数必须为handler</u>
3. immediate（立即侦听）：如果需要默认一进页面就触发一次，添加immediate配置选项为true
{% endnote %}

## webpack
{% note success no-icon flat %}
{% span red, 定义 %}：是一个打包模块化的工具，在webpack中一切文件皆为模块，通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合成的文件
{% span red, 作用 %}：由于浏览器对于js中的很多代码不可以直接进行解析读取，这个时候需要先通过 wabpack 把资源进行打包，解析成浏览器可以识别的代码
{% span red, 配置 %}： 
  - 入口：指示webpack使用哪个模块作为构建其内部依赖图的开始，默认值是：‘./src/index.js’
  - 出口：告诉webpack在哪里输出它所创建的bundle，以及如何命名这些文件，主要输出文件的默认值是‘./dist/main.js’
  - mode：配置模式，development(开发环境)、production(生产环境)、none(不使用任何默认优化选项)
  - loader：自带能力，用于转换某些类型的模块
  - plugin：打包优化，资源管理，注入环境变量等

{% span red, 流程 %}： 
  - 初始化参数
  - 开始编译
  - 确定入口
  - 编译
  - 完成模块编译
  - 输出资源
  - 输出完成
{% endnote %}

## 一个页面从输入 URL 到页面加载显示完成的过程
{% note success no-icon flat %}
- 浏览器查找域名对应的IP地址，向服务器发送一个请求
- 服务器重定向
- 浏览器追踪重定向地址，请求另一个带www的网址
- 服务器处理请求读取资源，返回一个响应
- 浏览器构建dom树，发请求获取页面资源完成页面
{% endnote %}

## 纯函数
纯函数就是一个函数，只不过具有一些特点，你可能平时开发中都有用到，只是没有意识到这是一个纯函数。
纯函数（Prue function）具有以下特点：
1. 纯函数每一次调用时传入同样的参数，返回的都是同样的结果；它不会改变参数的值，也不会改变外部变量的值；它不会依赖于外部的变量，仅依赖于你传入的参数；
2. 纯函数没有其他副作用（side effect）
3. 如果你每次传入的参数一样，但是返回的结果不一样，则不是一个纯函数

这是一个纯函数:
```js
/*
    它没有改变外部变量的值
    每次调用时如果传递的值相同，那每次返回的结果也相同
*/
let a = 1;
let b = 2;
function add(x, y) {
    return x + y;
}
add(a, b);
```
这不是一个纯函数:

## H5事件
{% note success no-icon flat %}
- onblur失焦事件
- onfocus聚焦事件
- onchange改变事件
- onclick点击事件
- onerror错误事件
- oninput输入事件
- onkeydown键盘按下事件
- onkeyup键盘抬起事件
- onmousemove鼠标移动事件
- onmouseover鼠标进入事件
- onmouseout鼠标移出事件等
{% endnote %}

## Vue组件通讯
{% note success no-icon flat %}
- 父传子：子组件定义props属性接收
- 子传父：子组件中使用this.$emit方法
- 兄弟传值：事件总线，$on方法
- 父传孙：provide和inject方式
{% endnote %}

## 插槽
{% note success no-icon flat %}
1. 什么是插槽
  - 插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。
  - 插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制
2. 插槽使用
  - 默认插槽 : 在子组件中写入slot，slot所在的位置就是父组件要显示的内容
  - 具名插槽：
    - 在子组件中定义了三个slot标签，其中有两个分别添加了name属性header和footer
    - 在父组件中使用template并写入对应的slot名字来指定该内容在子组件中现实的位置
  - 作用域插槽：
    - 在子组件的slot标签上绑定需要的值<slot :data="user"></slot>
    - 在父组件上使用slot-scope=“user”来接收子组件传过来的值 
{% endnote %}

## 如何封装组件
{% note success no-icon flat %}
- 原因：封装组件可以提升项目开发效率，把页面抽象成多个相对独立的模块，复用性高
- 步骤： 
  - 创建一个组件
  - Vue.component注册组件
  - 子组件需要数据，可以在props中接受定义
  - 而子组件修改好数据后，想把数据传递给父组件，可以采用emit方法
{% endnote %}

## nextTick的理解
{% note success no-icon flat %}
使用nextTick的原因：Vue是异步修改DOM的，并且不鼓励开发者直接接触DOM，但是有时候必须对数据更改后的DOM元素做相应的处理（例如：下面代码），但是获取到的DOM数据并不是更改后的数据，这时候就需要nextTick()来帮我们实现了
```html
<button @click="change()">按钮</button><h1 ref="gss">{{msg}}</h1>

<script>
export default{
  name:"app",
    data(){
    return {
      msg:"123"
    }
  },
  methods:{
    change(){
      this.msg = "456";
      console.log(this.refs["gss"].innerHTML)//123
      this.$nextTick(function(){
        console.log(this.refs["gss"].innerHTML)//456
      })
    }
  }    
}
</script>
```
{% endnote %}

## 路由模式
{% note success no-icon flat %}
hash模式： 
  - 浏览器中符号是“#”，#以及#后面的字符称之为 hash，又叫前端路由
  - 用 window.location.hash 读取
  - hash 虽然在 URL 中，但不被包括在 HTTP 请求中
  - hash 改变会触发 hashchange 事件
  - hash发生变化的url都会被浏览器记录下来，从而浏览器的前进后退都可以用

history模式： 
  - history 采用 HTML5 的新特性
  - history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中
  - 它也有个问题：不怕前进，不怕后退，就怕{% span red, '刷新' %}（如果后端没有准备的话，会分分钟刷出一个404来），因为刷新是实实在在地去请求服务器的
{% endnote %}

## SPA
{% note success no-icon flat %}
- 单页面应用，将所有的活动局限于一个web页面中，仅在初始化的时候加载HTML、JS、CSS，一旦页面加载完成，就不会因为用户的操作而进行页面的重新加载或跳转
- 利用JS的动态变化HTML内容，实现交互，避免页面的重新加载
{% endnote %}

## 路由之间跳转方式
{% note success no-icon flat %}
四种方式： 
- router-link：搭配to属性，在模板中使用
- push()：跳转到指定页面
- replace()：跳转到指定页面，但是没有历史记录跳不回去
- go(N)N：可以为正数也可以为负数，正数是向前跳转，负数是向后跳转
{% endnote %}

## 组件创建和挂载相关的钩子函数 
{% note success no-icon flat %}
- beforeCreate
- created
- beforeMount
- mounted
{% endnote %}

## 组件更新相关的钩子函数
{% note success no-icon flat %}
- beforeUpdate
- updated
{% endnote %}

## Vue组件之间的传递方式
{% note success no-icon flat %}
`[回答第1,2条-合格，因为是常用的]`
1. 父组件向子组件传递数据，使用props属性；子组件向父组件中传递数据，在子组件中使用$emit派发事件，父组件中使用v-on监听事件。缺点:组件嵌套层次多的话，传递数据比较麻烦。
2. 通过Vuex，实现多个组件进行数据共享，推荐使用这种方式进行项目中各组件间的数据传递。

`[如果还能将第3条回答出-良好]`
1. 通过事件总线(eventbus)的方式，可以实现任意两个组件间进行数据传递;缺点:不支持响应式，这个概念是vue1.0版本中的，现在已经废弃

`[如果还能将第4,5条回答出-优秀]`
1. 祖先组件通过依赖注入(inject/provide)的方式，向其所有子孙后代传递数据;缺点:无法监听数据修改的来源，不支持响应式。
2. 通过属性parent/$children/ref，访问根组件、父级组件、子组件中的数据;缺点:要求组件之间要有传递性。
{% endnote %}

## 三次握手和四次挥手：
{% note success no-icon flat %}
三次握手： 
- 发送端首先发送一个带有SYN标志的数据包给接收方
- 接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了
- 发送方再回传一个带有ACK标志的数据包，代表我知道了，表示‘握手’结束

四次挥手： 
- Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态
- Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态
- Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态
- Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手
{% endnote %}

## 组件销毁相关的钩子函数
{% note success no-icon flat %}
- beforeDestroy
- destroyed
{% endnote %}

# 性能提升
## innerText和textContent的区别
{% note success no-icon flat %}
- 设置文本替换时，两者都会把指定节点下的所有子节点也一并替换掉。
- textContent 会获取所有元素的内容，包括 `<script>` 和 `<style>` 元素，然而 innerText 不会。
- innerText 受 CSS 样式的影响，并且不会返回隐藏元素的文本，而textContent会。
- 由于 innerText 受 CSS 样式的影响，它会触发回流重排（reflow），但 textContent 不会。
- innerText 不是标准制定出来的 api，而是IE引入的，所以对IE支持更友好。
- textContent虽然作为标准方法但是只支持IE8+以上的浏览器，在最新的浏览器中，两个都可以使用。
综上，Vue这里使用textContent是从性能的角度考虑的。
从性能上考虑的话，textContent的性能的确要比innerText的执行效率要高
{% endnote %}